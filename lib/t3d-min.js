var T3D;!function(t){t.RAD_SCALE=Math.PI/180;class s{constructor(t,s,r){this.x=0,this.y=0,this.z=0,this.set(t,s,r)}set(t,s,r){return"number"==typeof t&&(this.x=t),"number"==typeof s&&(this.y=s),"number"==typeof r&&(this.z=r),this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){let s=this.x,r=this.y,e=this.z,i=t.x,h=t.y,a=t.z;return this.x=r*a-e*h,this.y=e*i-s*a,this.z=s*h-r*i,this}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}scale(t){return this.x*=t,this.y*=t,this.z*=t,this}normalize(){var t=this.length();return t>0&&this.scale(1/t),this}clone(){return new s(this.x,this.y,this.z)}invert(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}toArray(){return[this.x,this.y,this.z]}}t.Vec3=s;class r{constructor(t){this.data=t||[0,0,0,0,0,0,0,0,0]}transpose(){const t=this.data,s=t[1],r=t[2],e=t[5];return t[1]=t[3],t[2]=t[6],t[3]=s,t[5]=t[7],t[6]=r,t[7]=e,this}}t.Mat3=r;class e{constructor(t){this.data=t||[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}clone(){return new e(this.data)}multiply(t){const s=this.data,r=s[0],e=s[1],i=s[2],h=s[3],a=s[4],n=s[5],o=s[6],c=s[7],l=s[8],u=s[9],m=s[10],f=s[11],p=s[12],y=s[13],d=s[14],g=s[15],A=t[0],x=t[1],w=t[2],z=t[3],M=t[4],v=t[5],b=t[6],S=t[7],E=t[8],R=t[9],F=t[10],T=t[11],D=t[12],L=t[13],P=t[14],_=t[15];return this.data=[r*A+e*M+i*E+h*D,r*x+e*v+i*R+h*L,r*w+e*b+i*F+h*P,r*z+e*S+i*T+h*_,a*A+n*M+o*E+c*D,a*x+n*v+o*R+c*L,a*w+n*b+o*F+c*P,a*z+n*S+o*T+c*_,l*A+u*M+m*E+f*D,l*x+u*v+m*R+f*L,l*w+u*b+m*F+f*P,l*z+u*S+m*T+f*_,p*A+y*M+d*E+g*D,p*x+y*v+d*R+g*L,p*w+y*b+d*F+g*P,p*z+y*S+d*T+g*_],this}scale(t){return this.multiply([t.x,0,0,0,0,t.y,0,0,0,0,t.z,0,0,0,0,1])}translate(t){return this.multiply([1,0,0,0,0,1,0,0,0,0,1,0,t.x,t.y,t.z,1])}rotateX(t){const s=Math.cos(t),r=Math.sin(t);return this.multiply([1,0,0,0,0,s,r,0,0,-r,s,0,0,0,0,1])}rotateY(t){const s=Math.cos(t),r=Math.sin(t);return this.multiply([s,0,-r,0,0,1,0,0,r,0,s,0,0,0,0,1])}rotateZ(t){const s=Math.cos(t),r=Math.sin(t);return this.multiply([s,r,0,0,-r,s,0,0,0,0,1,0,0,0,0,1])}rotate(t){return this.rotateX(t.x).rotateY(t.y).rotateZ(t.z)}perspective(t,s,r,e){const i=Math.tan(.5*Math.PI-.5*t),h=1/(r-e);return this.multiply([i/s,0,0,0,0,i,0,0,0,0,(r+e)*h,-1,0,0,r*e*h*2,0])}invert(){const t=this.data,s=t[0],e=t[1],i=t[2],h=t[4],a=t[5],n=t[6],o=t[8],c=t[9],l=t[10],u=l*a-n*c,m=-l*h+n*o,f=c*h-a*o,p=s*u+e*m+i*f;if(!p)return null;const y=1/p;return new r([u*y,(-l*e+i*c)*y,(n*e-i*a)*y,m*y,(l*s-i*o)*y,(-n*s+i*h)*y,f*y,(-c*s+e*o)*y,(a*s-e*h)*y])}}t.Mat4=e;class i{constructor(t=[]){this.translate=new s(t[0]||0,t[1]||0,t[2]||0),this.rotate=new s(t[3]||0,t[4]||0,t[5]||0),this.scale=new s(t[6]||1,t[7]||1,t[8]||1)}matrix(s){return(s=s||new e).scale(this.scale).rotate(this.rotate.clone().scale(t.RAD_SCALE)).translate(this.translate),this.parent?this.parent.matrix(s):s}}t.Transform=i;class h{constructor(t=1,r=45,e=.1,i=100){this.rotate=new s,this.position=new s,this.fov=r,this.aspect=t,this.near=e,this.far=i}transform(t){return t.matrix().rotate(this.rotate.clone().invert()).translate(this.position.clone().invert())}perspective(){return(new e).perspective(this.fov,this.aspect,this.near,this.far)}}t.Camera=h;class a extends s{constructor(){super(...arguments),this.faces=[]}addFace(t){return this.faces.push(t),this}}class n{constructor(t,s,r){this.verts=[],this.normals=[],t.addFace(this),s.addFace(this),r.addFace(this),this.verts.push(t,s,r),this.normal=s.clone().sub(t).cross(r.clone().sub(t)).normalize()}calcNormals(t){return this.verts.forEach((s,r)=>{let e;s.faces.forEach(s=>{this.normal.dot(s.normal)>t&&(e=e?e.add(s.normal):s.normal.clone())}),this.normals.push(e?e.normalize():this.normal)}),this}pushVerts(t){return this.verts.forEach(s=>{t.push(...s.toArray())}),this}pushNormals(t){return this.normals.forEach(s=>{t.push(...s.toArray())}),this}}class o{constructor(s,r=[],e=0,i=360){if(this.verts=[],this.normals=[],s<2)return;r.length<2&&(r=this.sphere(r.length>0?r[0]+2:Math.ceil(s/2)+1));const h=this.createVerts(s,r,0,i),a=this.createFaces(h,s,r.length/2),n=Math.cos(e*t.RAD_SCALE);a.forEach(t=>{t.calcNormals(n).pushVerts(this.verts).pushNormals(this.normals)})}sphere(t){const s=[];if(t<3)return;let r=Math.PI/(t-1);for(let e=1;e<t-1;e++){let t=r*e;s.push(Math.sin(t)/2),s.push(Math.cos(t)/2)}return s}createVerts(s,r,e,i){e*=t.RAD_SCALE;let h=[],n=((i*=t.RAD_SCALE)-e)/s;h.push(new a(0,.5,0)),h.push(new a(0,-.5,0));for(let t=0;t<s;t++){let s=n*t+e,i=Math.cos(s),o=Math.sin(s);for(let t=0;t<r.length;t+=2){let s=new a(i,0,o);s.scale(r[t]).y=r[t+1],h.push(s)}}return h}createFaces(t,s,r){const e=[];let i;for(let h=1;h<s;++h){i=h*r+2,e.push(new n(t[0],t[i],t[i-r])),e.push(new n(t[1],t[i-1],t[i+r-1]));for(let s=0;s<r-1;s++){let h=i+s;e.push(new n(t[h+1],t[h-r],t[h])),e.push(new n(t[h-r+1],t[h-r],t[h+1]))}}e.push(new n(t[0],t[2],t[i])),e.push(new n(t[1],t[i+r-1],t[r+1]));for(let s=0;s<r-1;s++){let r=i+s;e.push(new n(t[s+3],t[r],t[s+2])),e.push(new n(t[r+1],t[r],t[s+3]))}return e}}t.Mesh=o;class c{constructor(t,s,r){this.childs=[],this.mesh=t,this.color=s,this.transform=new i(r)}add(t){return this.childs.push(t),t.transform.parent=this.transform,this}}t.Item=c;class l{constructor(t,s,r){this.attribs={},this.location={},this.gl=t,this.program=t.createProgram(),this.indices=t.createBuffer();const e=this.program;t.attachShader(e,this.create(t.VERTEX_SHADER,s)),t.attachShader(e,this.create(t.FRAGMENT_SHADER,r)),t.linkProgram(e),t.getProgramParameter(e,t.LINK_STATUS)||(console.log(t.getProgramInfoLog(e)),t.deleteProgram(e))}create(t,s){const r=this.gl,e=r.createShader(t);return r.shaderSource(e,s),r.compileShader(e),r.getShaderParameter(e,r.COMPILE_STATUS)||console.log(r.getShaderInfoLog(e)),e}attrib(t,s,r){const e=this.gl;this.location[t]||(this.location[t]=e.getAttribLocation(this.program,t),this.attribs[t]=e.createBuffer());const i=this.location[t];return e.bindBuffer(e.ARRAY_BUFFER,this.attribs[t]),e.bufferData(e.ARRAY_BUFFER,new Float32Array(s),e.STATIC_DRAW),e.enableVertexAttribArray(i),e.vertexAttribPointer(i,r,e.FLOAT,!1,0,0),this}uniform(t,s){const r=this.gl;this.location[t]||(this.location[t]=r.getUniformLocation(this.program,t));const e=this.location[t];if("number"==typeof s)return r.uniform1f(e,s),this;switch(s.length){case 2:r.uniform2fv(e,s);break;case 3:r.uniform3fv(e,s);break;case 4:r.uniform4fv(e,s);break;case 9:r.uniformMatrix3fv(e,!1,s);break;case 16:r.uniformMatrix4fv(e,!1,s)}return this}}t.Shader=l}(T3D||(T3D={}));